计算机研究与发展
JOURNAL OF COMPUTER RESEARCH AND DEVELOPMENT
1999年 第36卷 第8期 Vol.36 No.8 1999



ADA程序通信死锁的动态检测方法
史晓华　高仲仪　邵　晖
摘　要　针对ADA并发多任务程序的特点，文中提出一个新的ADA程序动态死锁检测方案，并且在这个理论的基础上实现了一个动态死锁测试工具DDTT(dynamic deadlock testing tool).此工具能够正确检测ADA多任务程序由于通信关系不当而造成的死锁.文中详细介绍了动态死锁测试工具DDTT所依赖的全部概念及判定规则，以及它的工作原理.
关键词　死锁，ADA程序，动态检测
中图法分类号　TP311
A DYNAMIC DEADLOCK TESTING METHOD OF A CONCURRENT ADA PROGRAM
SHI Xiao-Hua, GAO Zhong-Yi, and SHAO Hui
(Software Engineering Institute， Beijing University of Aeronautics and Astronautics Beijing 100083)
Abstract　According to the features of ADA concurrent programs, a new theory is introduced, which can be used to detect most deadlocks in an ADA program. A deadlock detecting tool named DDTT(dynamic deadlock testing tool) relying on this theory is designed. This detecting tool can be used to detect communicating deadlocks in a multi-task ADA program. The theory and detecting rules used by DDTT are described in detail. Finally, the working principle of DDTT is introduced.
Key words　deadlock, ADA program, dynamic detecting
1　引　言
　　ADA语言是美国国防部领导研制的三军通用语言,它在分布式系统中得到了广泛的应用,其主要原因是由于ADA提供了强有力的不依赖于平台的多任务编程环境.但分布式程序有几个特殊问题需要妥善解决, 其中之一就是如何防止死锁.任务(task)作为并发ADA程序中最基本的单元，由于其中不恰当的通信语句时序可以导致程序的死锁，这种类型的死锁是可能通过分析及监控检查出来的.
　　静态死锁检测是发展得较早的死锁检测方法，其中有代表性的两种方法分别为有序集［1］和Petri网.勿庸质疑对程序做静态分析可以得到一个比较全面透彻的了解，如果借助一个好的分析模型，是可能对一个被测程序的各个方面得到比较全面的理解和判定的.但是静态的分析工具有两个问题是很难处理的：一是程序中的任务数组、入口族等必须在实际运行中决定的情况；二是静态的分析方法为了追求全面，最终导致NP问题、组合爆炸.同时对用户来说，静态分析得到的“可能”死锁的报告是不能够满足的.他们更关心在实际运行时是否会产生死锁，实际运行时的“死机”是否为死锁等等非常具体的问题.因此，国外在此领域已经有所研究.较有代表性的是Jinde Cheng提出的ADA语言中死锁的完全分类方法并且给出了相应的解决方法，并提出了一个采用动态监控方式进行实时死锁检测的方案［2］，而在国内尚未见到有这样的研究成果.本文所作的主要工作是：给出了ADA任务通信死锁的定义；提出了描述单元通信关系的UDG图的形式化表示方法；提出并证明了死锁的判定定理；以及在上述理论工作的基础上实现了一个动态检测ADA任务通信死锁的工具原型.
　　文中将首先讨论采用动态监控手段检测ADA程序中由于任务通信语句的不恰当时序而导致死锁所依赖的主要理论，然后简单介绍在此基础上我们业已实现的一个动态死锁检测工具DDTT(dynamic deadlock testing tool).
2　动态死锁检测的理论准备
2.1　任务通信死锁的定义
　　定义1. 通信语句
　　我们称一个任务的入口接收语句或针对某一任务的入口调用语句为ADA语言的通信语句.
　　定义2. ADA语言的任务通信死锁
　　一个并发ADA程序的任务通信死锁是指程序中一个或多个任务的通信语句处于一种并非死循环导致的无限等待状态，从而导致这些任务无法执行下去(如不特别注明，文中提及的“死锁”即为“ADA语言任务通信死锁”).
2.2　死锁的判定方法
2.2.1　单元通信关系的UDG图表示方法.
　　首先是一些重要的概念准备［3］：
　　定义3. 可执行单元可分为如下4类：
　　(1) Subprogram: 包括 ① procedure， ② function；
　　(2) Block: 包括 ① declare-block， ② accept-block；
　　(3) Task: 包括 ① task body， ② the object of a task type；
　　(4) Package: 包括 ① package specification， ② package body.
　　定义4. 活动单元
　　我们称一个可执行单元为活动的，当且仅当满足以下两种情况中的一种：
　　(1) 对于一个拥有with packages的主单元而言，程序开始执行其直接或间接with 的package的代码；
　　(2) 对于其他可执行单元而言，程序开始执行属于此单元的首行代码；
并且这个单元的运行没有终止.
　　特别地，程序在不同时刻或不同位置调用同一个Subprogram或声明同一个task type的不同对象或执行同一段task body 的代码，我们定义它们针对某一特定时刻是不同的活动单元.针对递归程序而言，此点尤为重要.
　　定义5. 活动单元的确立阶段(elaboration)
　　我们称一个活动单元处于确立阶段，当且仅当此活动单元尚未完成其声明部分代码的运行.
　　定义6. 活动单元的执行阶段
　　我们称一个活动单元处于执行阶段，当且仅当此活动单元不处于确立阶段.
　　定义7. 活动单元的完成状态
　　我们称一个处于执行阶段的活动单元为完成状态，当且仅当此单元执行到其END语句之前而尚未执行它的结束语句.
　　定义8. 终止单元
　　我们称一个活动单元在完成其END语句的执行之后，此单元为终止的.
　　定义9. 外延单元
　　我们称一个活动单元Unit1为另一个活动单元Unit2的外延单元，当且仅当它们满足以下3种关系中的一种：
　　(1) Unit1是Unit2通过with语句直接或间接引用的包，并且Unit2为这个并发ADA程序的主单元；
　　(2) Unit1是Unit2调用的子程序；
　　(3) Unit1是Unit2体中直接声明的属于定义3中类2中的单元.
　　定义10. 直接激活
　　我们称一个活动的Task或Task Type的对象是被一个属于定义3类1，2，3中的活动单元直接激活的，当且仅当这个任务满足以下两种关系中的一种：
　　(1) 这个task或task type的对象是在这个可执行单元的声明部分直接说明的；
　　(2) 这个task或task type的对象是在被这个可执行单元直接或间接引用的包中（包括包的体及包的声明）直接说明的，并且这个可执行单元是这个并发ADA程序的主单元.
　　定义11. 单元标识码
　　在一个并发ADA程序中，每一个活动单元都拥有一个唯一的标识码直至其进入终止状态；此码作为区分不同活动单元的唯一标识.
　　定义12. 任务标识码
　　在一个并发ADA程序中，每个活动单元（包括定义3中所有4类可执行单元）都拥有一个任务标识码.对于每个活动或终止的task或task type的对象而言，此码都是唯一的.即不同的task或task type的对象或同一task type 的不同对象都拥有一个可以唯一区分自己的任务标识码.
　　特别地，我们定义一个不具有任务的顺序流程序中的所有活动单元都拥有一个同样的任务标识码.
　　定义13. 我们定义两个活动单元Unit1，Unit2拥有同样的任务标识码，当且仅当这两个单元满足以下两种关系中的一种：
　　(1) Unit1为Unit2的外延单元，或反之；
　　(2) 存在这样一个有序集合：
｛P1，…，Pm｝　　m＞0；
　　　　① P1为Unit1的外延单元；
② Unit2为Pm的外延单元；
③ 对于任何存在的1＜i≤m，Pi为Pi-1的外延单元；
或将上述的Unit1与Unit2变换位置.
　　定义14. 父单元
　　我们称直接激活一个task或task type的对象的活动单元为此任务的父单元.由定义12可知，一个任务单元的父单元的任务标识码不同于此任务的任务标识码，并且也不同于非它本身的任何其它活动或终止的任务单元的任务标识码.
　　定义15. 活动单元的完成等待状态
　　我们称一个活动单元处于完成等待状态，当且仅当它同时满足以下两种情况：
　　(1) 此活动单元处于完成状态；
　　(2) 此活动单元直接激活的任务中，尚有未处于终止状态的单元.
　　定义16. 单元描述图(unit description graph)
　　我们定义这样一个有向图，它针对于某一特定时刻t（对于实时嵌入式系统interleaved implementation，t为某一物理时刻；对于分布式系统distributed implementation，t为某一虚时刻），某一特定的被测并发ADA程序P：用符号表示为UDG(P,t)，对应一个9元组的有向图：
(OA(P,t)，OF(P,t)，E(P,t)，Aact，Aext，Acall，Aacc，D，W)
(1) OA(P,t)＝OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t) ∪ OAP(P,t)
其中OAT(P,t)表示所有在时刻t的属于定义3类3中的活动单元；
　　OAB(P,t)表示所有在时刻t的属于定义3类2中的活动单元；
　　OAS(P,t)表示所有在时刻t的属于定义3类1中的活动单元；
　　OAP(P,t)表示所有在时刻t的属于定义3类4中的活动单元；
　　(2) OF(P,t)＝OFT(P,t) ∪OFB(P,t) ∪ OFS(P,t) ∪ OFP(P,t)
其中OFT(P,t)表示所有在时刻t之前终止的属于定义3类3中的单元；
　　OFB(P,t)表示所有在时刻t之前终止的属于定义3类2中的单元；
　　OFS(P,t)表示所有在时刻t之前终止的属于定义3类1中的单元；
　　OFP(P,t)表示所有在时刻t之前终止的属于定义3类4中的单元；
　　(3) E(P,t)为P中所有在时刻t的活动单元及时刻t之前终止的任务单元的入口声明的集合；
　　(4) Aact＝OA(P,t)×OAT(P,t)
　　Aact表示OA(P,t)与OAT(P,t)之间的这样一种二元关系：
　　对于任意的V1∈OA(P,t)，V2∈OAT(P,t)，当且仅当V2是被V1直接激活的，(V1,V2) ∈Aact；
　　(5) Aext＝OA(P,t)×（OAB(P,t) ∪ OAS(P,t) ∪ OAP(P,t)）
　　Aext表示OA(P,t)与OAB(P,t) ∪ OAS(P,t) ∪ OAP(P,t)之间的这样一种二元关系：
　　对于任意的V1∈OA(P,t)，V2∈OAB(P,t) ∪ OAS(P,t) ∪ OAP(P,t)，当且仅当V2是V1的外延单元，(V1,V2) ∈Aext；
　　(6) Acall＝（OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t) ）×（OAT(P,t) ∪ OFT(P,t)）×E(P,t) 
　　Acall表示OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t)与OAT(P,t) ∪ OFT(P,t)与E(P,t) 之间的这样一种三元关系：
　　对于任意的V1∈OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t)，V2∈OAT(P,t) ∪ OFT(P,t)，e∈E(P,t)，当且仅当V1无条件调用属于V2声明的入口e，(V1, V2 ,e) ∈Acall；
　　(7) Aacc＝（OAT(P,t) ∪OAB(P,t) ）×（OAT(P,t) ∪OAB(P,t) ）×E(P,t)
　　Aacc表示（OAT(P,t) ∪OAB(P,t) ）与（OAT(P,t) ∪OAB(P,t) ）与E(P,t) 之间的这样一种三元关系：
　　对于任意的V1∈（OAT(P,t) ∪OAB(P,t) ），e∈E(P,t)，当且仅当满足以下两个条件中的一种：
　　.V1无条件接收等待一个入口e；
　　.V1在一个选择段中条件接收入口e，并且同时满足下列4个条件：
　　　　① e已经进入V1的接收等待队列；
② e还没有进入其会合阶段的执行；
③ e没有被一个时间限制或被一个else语句所约束或被一个orterminate语句所约束；
④ 不存在a=(V1，Vk) ∈Aext；(V1，V1，e) ∈Aacc.
　　(8) D＝OA(P,t)×OAT(P,t)
　　D表示OA(P,t)与OAT(P,t)之间的这样一种二元关系：
　　对于任意的V1∈OA(P,t)，V2∈OAT(P,t)，当且仅当下列3个条件同时成立：
　　　　① (V1,V2) ∈Aact；
② V1，V2都处于活动单元的确立阶段；
③ 不存在这样一个V3∈OAT(P,t)，使得(V2,V3) ∈D；(V1,V2) ∈D.
　　(9) W＝（OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t)）×OAT(P,t)
　　W表示OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t)与OAT(P,t)之间的这样一种二元关系：
　　对于任意的V1∈OAT(P,t) ∪OAB(P,t) ∪ OAS(P,t)，V2∈OAT(P,t)，当且仅当下列两个条件同时成立：
　　　　① V1处于完成等待状态；
② (V1,V2) ∈Aact；(V1,V2) ∈W.
2.2.2　死锁的判定定理
　　定理1. 活动单元死锁的充分条件：给定一个UDG(P,t)中：
　　(1) 存在a =（V1，V2，e1）∈Acall；
　　如果V2∈OFT，我们称V1由于呼叫一个已经终止的单元而导致死锁.
　　(2) 存在a =（V1，V2，e1）∈Acall；
　　如果V2∈OAT并且V2处于完成状态，我们称V1由于呼叫一个已经完成的单元而导致死锁.
　　(3) 存在a =（V1，V2，e1) ∈Acall；
　　如果V2已经处于死锁状态，我们称V1由于呼叫一个已经死锁的单元而导致死锁.
　　(4) 存在a =（V1，V2) ∈Aext；
　　如果V2已经处于死锁状态，我们称V1为死锁的.
　　(5) 存在a =（V1，V2) ∈D；
　　如果V2已经处于死锁状态，我们称V1为死锁的.
　　(6) 存在a =（V1，V2) ∈W；
　　如果V2已经处于死锁状态，我们称V1为死锁的.
　　(7) 存在一个有向环：a1 ，…，an ， n≥1
　　其中　　ai ∈Acall ，或
　　　　　　ai ∈Aext ，或
　　　　　　ai ∈D ，或
　　　　　　ai ∈W　（1≤i≤n) ，
　　并且当我们把ai=（Vi，Vi+1，ei) ∈Acall写成 的形式时，这个有向环可以表示为 
（V1，V2) ，…，（Vn，V1) ； 
　　我们认为所有这个环上的节点Vi∈OA（1≤i≤n) 都是死锁的.
　　证明. 根据ADA语义，(1)～(6)是成立的.下面我们仅证明(7).
　　首先根据定义4、9、10、16可知：(1)中定义的有向环中，存在并且至少存在一个ai ∈Acall.
　　下面我们根据数学归纳法来证明这一结论.
　　由死锁的定义(定义1)，不防设a1=（Vi，Vi+1，ei) ∈Acall：
　　① 当这个环中只有一个边，即n=1时：
a1=（V1，V1，ei) .
　　我们知道一个呼叫了自身入口的调用永远不能产生会合，由定义2可知V1为死锁的.即对于所有的Vi（1≤i≤n) ，Vi为死锁的.
　　② 假设n=k时，对于拥有k条边的有向环中所有的Vi（1≤i≤n) ，Vi为死锁的.当我们把它写成(1)中描述的简写形式时有
（V1，V2) ，…，（Vk，V1) ；
　　③ 当n=k+1时，由题设知ak+1 ∈Acall或Aext或D或W.我们首先讨论当ak+1=（Vk+1，V1，ek+1) ∈Acall时的情况：
　　将a1～ak+1写成(1)中描述的简写形式：
（V1，V2) ，…，（Vk，Vk+1) ，（Vk+1，V1) ；
　　由定义16可知，Vk能否继续执行将取决于Vk+1的运行状态，而Vk+1能否继续执行――即能否同V1产生一个会合,将取决于V1的运行状态，也就是Vk通过Vk+1将依赖于V1的运行状态.这样我们看到在V1-V2…-Vk-V1之间产生了一个相互依赖的环，而根据(2)中的假设，这样的环上每一个节点都是死锁的.由(3)可知，（Vk+1，V1，ek+1) 中由于Vk+1呼叫了一个已经死锁的节点V1，因此Vk+1也是死锁的.即对于所有的Vi（1≤i≤k+1) 都是死锁的.
　　当ak+1 ∈Aext或D或W时，由定义16及上述证明同理可知这个有向环上的所有结点都为死锁的.
　　定理2. 死锁的判定定理
　　给定一个UDG(P,t)，对于任意的Vj属于OA，当它满足以下两种条件之一，我们称这个程序中的所有活动单元为死锁的：
　　(1) 根据定理1，可判定Vj为死锁的；
　　(2) 存在这样的有向链：
　　a1 ，…，an ，　n≥0；
　　当n＞0时，其中
　　　　　　ai∈Acall ，或
　　　　　　ai∈Aext ，或
　　　　　　ai∈D ，或
　　　　　　ai∈W　　（1≤i＜n) ；
　　an=（Vn，Vn，en) ∈Aacc；
　　a1是从节点Vj引出的边.
　　这个有向链满足这样的特性：
　　如果存在一个最靠近an的am=（Vm，Vm+1，em) ∈Acall ，并且Vm+1的任务标识码与Vn的任务标识码相同，那么不存在（Vn，Vn，ek) ∈Aacc，使得ek=em.
　　证明. 即证如果一个UDG图中所有活动单元满足上述两个条件之一，这个程序中的所有活动单元为死锁的.
　　如果一个活动单元Vj满足条件1，显见它是死锁的；
　　如果这个活动单元满足条件2，即是说Vj能否继续执行取决于Vn是否可以产生一个会合.而由条件(2)中这个有向链的特性可知，根本不会存在这样的一个活动单元Vl，使得Vl呼叫Vn正在等待的入口并且产生一个会合.也就是说Vj不可能继续执行下去，它为死锁的.
3　动态死锁检测工具的实现
　　动态死锁检测工具DDTT由两部分组成，其一是预处理器，另一个是监控器.
3.1　预处理器
　　预处理器由静态分析器、源程序转换器及一个任务消息处理包组成.如图1所示.


图　1
　　静态分析器作为ADA程序理解的一个基础性的工具，它对文法上符合ADA83文本的ADA源代码进行分析.它不需要运行源程序，而是将ADA源程序作为系统的输入数据，自动地产生被测程序的静态属性表格，为动态测试以及其它测试奠定数据基础.
　　源程序转换器又称源码处理器，是整个预处理器中技术上的关键部分.顾名思义，这一部分的功能是将一个被测程序P转化为我们所需要的程序P′，而转化过程中所依赖的程序信息得自于静态分析器.我们总的原则是在程序中插装适当的语句来获知定义3～15中的各种单元的运行状态及它们之间的各种关系.
　　任务消息处理包单独编译后留在共享库中.由于它独立于任何不同的被测文件，因此被修改后的被测文件将引用这一个程序包.
3.2　监控器
　　监控器与被测程序将采用进程通信的手段来达到任务消息共享.我们在系统中辟出一块专用文件缓冲区用来进行被测程序与监控器之间的通信.
　　被测程序的任务消息处理是在一个独立的任务中进行，我们可以把这个任务看做是一个缓冲器，被测程序只需在插装位置上调用函数向内存中的消息队列写入有关信息即可；同时这个任务从内存中取出消息后放入文件缓冲区.监控器最终从文件缓冲区中取得相应的消息，根据前述定义及死锁的判定定理加以处理.
4　结束语
　　文中提出了在一个并发ADA程序起始运行后的任意时刻t，根据不同任务单元的状态来判断此程序是否处于由于通信设计不当而导致的死锁状态的解决方案.根据此方案并在本研究所“七五”、“八五”以来业已完成的ADA软件测试工具的基础上，我们实现了一个具有较好实用性、对此类死锁具有比较完全覆盖面的ADA程序动态死锁检测工具.完全解决死锁问题是还有很漫长的路要走的，但是我们本着了解一部分、解决一部分的方针，希望能够将问题缩小，在这一领域有所前进.
作者简介：史晓华，男，1973年3月生，博士研究生，主要研究领域为软件工程和软件测试技术.高仲仪，男，1935年1月生，教授，主要研究领域为形式语言与自动机理论、软件质量与可靠性、软件及软件工程环境、过程工程.邵晖，男，1969年5月生，硕士研究生，主要研究领域为嵌入式系统的开发与测试、软件工程及其环境.
作者单位：史晓华　高仲仪　邵　晖　北京航空航天大学软件工程研究所　北京　100083
参考文献
1　周伯生. ADA程序的死锁检测原理. 见: 周伯生主编. 计算机软件开发方法、工具和环境. 西安: 西北工业大学出版社，1985, 117～129
(Zhou Bosheng. A deadlock detecting theory of ADA program. In: Zhou Bosheng ed. Computer Software Developing Methods, Tools, and Environment(in Chinese). Xi'an: Northwest Industry University Press, 1985, 117～129)
2　Cheng Jingde. A survey of tasking deadlock detection methods. ACM Ada Letters, 1991, 11(1): 82～91
3　ANSI/MIL-STD-1815A-1983 Reference Manual for the Ada Programming Language. Washington: Ada Joint Program Office, 1983
收到日期：1997-11-19
修改日期：1999-03-08
