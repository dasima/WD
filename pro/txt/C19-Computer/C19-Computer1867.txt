微型机与应用
MICROCOMPUTER & ITS APPLICATIONS
2000 Vol.19 No.3 P.38-40



JavaBeans组件模型的分布式扩展机制
刘启文　傅韶勇　杨利
　　摘　要：结合JavaBeans技术和Java RMI技术提出了JavaBeans组件模型的分布式扩展机制,并在此基础上实现了基于JavaBeans的组件化分布式应用运行平台。
　　关键词：Java语言 JavaBeans组件模型 JavaRMI分布式处理
　　随着软件的规模逐渐庞大化,软件的可靠性、维护性等问题深深困扰着软件开发人员和用户。而且对于企业级应用而言,由于企业业务处于经常的变动之中,目前的应用软件较难快速适应这种改变。
　　组件技术为整个软件行业带来了新的生命力,组件的可重用性、可管理性和可替代性大大改善了软件本身的结构特征,能够有效地解决软件规模日益庞大所带来的种种问题。针对当前企业级应用的特点,开发了基于JavaBeans组件模型的组件化分布式应用运行平台,为企业系统管理提供了一个灵活的、可扩展的、集成的分布式组件框架。在此平台之上,应用系统中的各功能组件根据商业规则的驱动在分布式计算环境中动态地组合起来,并具有组件动态升级和组件之间的动态业务重组等关键特性,支持企业业务变化需求驱动下的系统快速重组和进化。
1 开发背景
　　本文介绍的平台是东北大学软件中心承担的“九五”国家科技攻关项目――“基于组件技术的应用软件开发环境”的部分研究内容。CADRE系统（Component-based Application Development & Runtime Environment）支持软件从设计、开发、分发、运行直至管理的各个阶段,整体分为3大部分:组件库管理系统CLMS、基于组件的分布式应用图形化建模工具ArchDesigner和组件化分布式应用运行平台CLAS。
　　组件化分布式应用运行平台是ArchDesigner开发环境基于的目标运行平台,其中该平台最重要的特征是支持了事件驱动的软件体系结构风格以及“业务逻辑与功能实现相分离”的思想。
　　事件是组件模型的三大基本元素之一,在事件驱动的软件体系结构风格中,组件禁止直接操纵其它任何组件,事件被规定为组件主动与外界交互的唯一途径,这提供了一种隐含调用（Implicate Invocation）的机制,降低了组件之间的耦合度,大大改善了组件化软件的系统结构。
　　在一般的软件开发模式下,系统业务逻辑都是硬编码,并被分割在系统的具体功能实现代码之中,运行时刻系统业务逻辑不可发现,系统在业务变化需求下无法实现动态升级。将业务逻辑从功能实现中分离出来,各功能组件独立存在,通过业务逻辑中所提供的接口拼装在一起,形成完整的系统。系统运行时刻,各功能组件通过各自的接口根据业务逻辑的描述进行交互,因此,各组件不依赖其它组件而存在,而且能够非常方便地被其它具有相同接口的组件所替换。
　　由于本平台是分布式计算环境下的组件化应用平台,企业业务逻辑装载在服务器端由规则虚拟机解释执行,功能组件分布在各客户端运行,通过分布式对象总线与服务器端的业务逻辑中的相应接口实现动态联编,各组件通过各自的接口在分布式对象总线上实现透明地互通信和互操作。而且,服务器作为本系统的控制中心需要管理整个分布式网络环境中的所有JavaBeans组件,包括组件监控、配置、访问控制和组件升级等,这些功能保证了整个企业应用具有良好的可管理性。
　　针对以上的系统功能需求,平台中的组件载体必须支持事件在分布式范围内的传播,以触发分布式环境中其它组件的相应动作,而且组件能够提供远程调用接口,使得服务器能够进行统一的、有序的、合理的管理,这样可以使系统中所有组件都运行在1个虚拟的统一地址空间中。由于JavaBeans是局限于单个Java虚拟机地址空间的组件模型,不具有分布式处理的能力,这就要求我们在不修改JavaBeans标准组件模型的前提下对其进行外部扩展,使之能适合分布式应用的需要。
2 组件模型分布式扩展的实现
2.1 分布式扩展方案
　　JavaBeans组件模型基本上是一个静态模型,它的基本思想是通过对程序的标准封装来实现可视化使用,从而快速构造应用。每个JavaBeans都附带了标准而且详细的说明类（BeanInfo）,描述了整个组件所有可暴露的属性、方法和事件,因此,组件框架能够正确地得到这些接口信息,并依此有效地管理和操纵组件。此外,JavaBeans独特的事件监听模型使得不同组件可以动态、灵活地组装起来,组件之间的耦合度得到大大降低。
　　但是,JavaBeans模型在2个方面无法适应本平台分布式应用的需求:①JavaBeans事件模型是在单个虚拟机地址空间中实现组件之间的同步交互操作,对于其它支持事件的组件模型也同样如此（如ActiveX）;②JavaBeans规范并不要求具有分布式对象的特征,JavaBeans组件仅能在本地地址空间被调用,除非该组件同时实现为1个分布式对象,但这又限制了JavaBeans组件的通用性和标准性。因此,本系统对JavaBeans组件模型设计了如下基本扩展方案:
　　1.业务逻辑采用脚本语言进行编写,系统的所有组件采用<用户名,组件名,实例编号>三元组件为组件逻辑句柄唯一标识,服务器端的脚本语言使用组件句柄操作运行在各地的功能组件。
　　2.各个JavaBeans组件运行在各自JVM的组件容器之中,各组件容器实现为所管理组件的监听器,能够捕获所有组件的事件,并负责将其发布在分布式范围之内。
　　3.脚本语言支持组件的事件监听器注册语法,能够将不同地址空间的组件按照事件监听关系在分布式环境中组装起来。
　　4.业务逻辑管理着系统中所有组件的逻辑句柄,并使用逻辑句柄通过各地的组件容器操作实际的组件实例。
　　5.事件的网络发布以及组件的远程操作都使用JavaRMI分布式对象技术实现,保证事件对象和方法调用参数通过分布式对象技术被正确地在分布式环境中传递,由于服务器端和客户端在交互中都具有主动性,双方都需实现为远程对象,供对方主动传送数据。
2.2 分布式扩展实现
　　在本系统,各分布结点在某一时刻代表着特定的用户身份,组件容器通过组件名和组件实例编号管理运行在该容器中的所有组件的实际句柄,并向其它分布结点提供名字服务,其它结点能够远程地访问容器中的任意组件。在业务逻辑中,组件逻辑句柄BeanHandle=<用户名,组件名,组件实例编号>,系统利用组件逻辑句柄把分布式运行的组件对象重新定位到统一的虚拟地址空间中,进行集中管理。在业务逻辑语法中,JavaBeans组件的接口和使用语法与在Java语言中基本保持一致,但语义实现却有许多不同。
　　1.方法调用。方法调用的语法形式为BeanHandle.<方法名>（<参数列表>）,规则虚拟机在解释运行该语句时,通过BeanHandle中的用户名确定该组件所在的客户端,得到该客户端的远程对象句柄,通过该远程对象将组件名、组件实例编号、方法名、参数列表发送到客户端,组件容器的名字服务由此查找到实际组件的实例句柄,最后使用Reflection API动态启动对组件的实际操作,方法如下:
　　public boolean InvokeMethod（<组件逻辑句柄>,<方法名>,<参数列表>）;
　　另外,组件实例创建的语法如下:
　　<组件名>BeanInstance=new<组件名>（<用户名>,<参数列表>）;
　　由于服务器端管理着整个系统的所有组件逻辑句柄,该操作能够为新的组件实例生成1个实例编号,与用户名、组件名形成唯一的组件逻辑句柄,最后该信息远程传输到相应客户端进行实际组件实例的创建。
　　2.事件的包装和发送。事件的包装在客户端进行。由于客户端中执行的组件是不可预知的,而且组件发出的事件各有不同,因此客户端的事件捕获功能必须具有通用性。组件容器在装载运行1个组件时,解析该组件并为该组件动态地创建1个临时事件监听器。该临时监听器捕获到组件事件后,对事件作如下包装:
　　<用户名,组件名,组件实例编号,事件对象,监听器名称,触发监听器方法名称>,使用服务器端的远程对象将包装后的事件通过RMI转发到服务器,业务逻辑于是触发该组件的所有监听器,下面给出了具体操作。
　　3.事件监听器的注册和注销。在业务逻辑语法中,事件监听器的语法与在Java语言中完全相同,如目前存在组件EventSource和其监听器Listener,则其注册和注销方法如下:
　　EventSourceHandle.add<XXX>Listener（ListenerHandle）;
　　EventSourceHandle.remove<XXX>Listener（ListenerHandle）;
　　规则虚拟机在解释这2个语句时,组件之间的事件监听关系将存储在1个监听表之中,监听表的内容包括:
　　<事件源逻辑句柄,监听器逻辑句柄,监听器类型名称>
　　当客户端经包装后的事件转发到服务器后,服务器将其解包,按照事件源逻辑句柄和监听器名称查找监听表,获得所有的监听器组件后,根据包装事件中的触发监听器方法名和事件对象远程操作实际组件,等价方法如下:
　　ListenerHandle.<监听器方法名称> （<事件对象>）;
2.3 分布式组件框架
　　基于扩展后的JavaBeans组件模型,相应地实现了在平台中的分布式组件框架。图1所示为整个平台的系统结构图,规则引擎是整个应用系统的控制中心,客户代理实现了“零管理”,应用系统的所有功能组件都存储在服务器端,在需要时动态、即时地加载到客户代理端运行。当然,在服务器端也能运行无UI界面的功能组件,从而提高整个系统的运行速度。在业务逻辑的驱动下,运行于各地的分布组件在服务器与客户端之间建立的分布式总线上进行透明的互操作。
　　图1所示的分布式总线是使用Java RMI技术实现的,该总线支持扩展后JavaBeans组件模型的事件传递、监听器触发以及组件远程调用,整个平台的功能大致可以分为以下5步:

图1 组件化分布式应用运行平台系统结构图
［注］α:事件通道 β:组件操作通道 γ:组件分发通道
　　第一步:客户代理的组件处理器接收远程组件调用操作,并解释执行该调用操作。对于创建组件实例操作,需首先通过γ通道从规则引擎中下载所需的组件（即JAR文件）,并安装在本地。
　　第二步:客户代理中的组件容器解析组件的JAR文件,获得组件接口信息,据此为该组件生成临时事件监听器。
　　第三步:系统运行过程中,临时事件监听器监听到相应组件的特定事件后,事件监听器将事件包装成标准的扩展事件形式,通过α通道转发给规则引擎。
　　第四步:规则引擎端的事件监听器收到扩展事件后,对该事件进行解包,由规则虚拟机中运行的业务逻辑确定下一步的操作。
　　第五步:规则引擎中的组件处理器得到规则虚拟机解释执行中触发的组件操作信息,包装成组件标准的扩展操作形式,通过β通道传送到指定的客户代理。
　　以上介绍的组件运行平台为企业管理提供了一个开放的、集成的、灵活的、可扩展的分布式计算环境。该平台实现采用了Java、JavaBeans组件模型和JavaRMI分布式对象技术,为使软件组件能够灵活组装在一起进行协同工作,设计了一种类似硬件总线式的软件总线。对于各种共享重用的组件,采用延迟绑定的动态连接方式运行,保证了组件动态、快速升级的特性。在这其中,我们研究了Java平台上的组件模型JavaBeans,并对其进行了逻辑上的扩展,使其满足组件化分布式应用运行平台下分布式操作的需求。
刘启文（沈阳宝钢东软集团软件中心