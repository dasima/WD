软件学报
JOURNAL OF SOFTWARE
2000　Vol.11　No.3　P.334-341



数据流分析中的区域覆盖技术
胡世亮　臧斌宇　凌冰　朱传琪
摘要　用计算函数模型进行精确的数据流分析,条件谓词之间的逻辑关系被转化为空间区域之间的覆盖关系.该文讨论在各种常见的程序构造下如何表示、计算和传递Ω区域、Φ区域，并在数据流分析过程中,利用Ω区域、Φ区域之间的覆盖关系消除条件分支语句带来的不确定性,以得到更精确的数据流信息.
关键词　Ω区域,Φ区域,数组数据流分析,数组私有化,符号分析.
中图法分类号　TP311
Region Coverage Method in Dataflow Analysis
HU Shi-liang ZANG Bin-yu LING Bing ZHU Chuan-qi
(Parallel Processing Institute Fudan University Shanghai 200433)
Abstract　For a precise dataflow analysis within the framework of the computation function model,the logical relationship of branch conditions is represented as the coverage relationship of regions.In this paper,the authors discuss how to represent,compute and propagate the Ω region,Φ region of the conditional reference.Meanwhile,the methods of resolving the nondeterminism caused by conditional branch statements are also presented in order to get more precise dataflow information.
Key words　Ω region,Φ region,array dataflow analysis,array privatization,symbolic analysis.
　　 区域覆盖的概念源自数组数据流分析.并行化编译器的编译对象主要是高性能计算领域中的科学计算程序.该类程序普遍的特点之一是,数据结构简单,数组和标量构成了数据集的主体.因此，数组数据流分析是并行化编译器的关键技术.数组区域(array region)的表示、运算及其相互之间的覆盖关系是数组数据流分析中的主要问题.
文献［1］提出的相关-覆盖方法就是利用数组区域的覆盖技术和相关性测试来解决数组私有化的判定问题.实验测试表明,相关-覆盖判定法是实效最好的数组私有化方法之一.但是该方法目前还不能处理条件分支语句所产生的流不确定性.鉴于数组私有化是众多并行化变换中最有效的方法之一［1,2］,有必要扩充相关-覆盖方法,使之能够处理条件分支语句产生的流不确定性.
　　在计算函数模型［3］下,条件读写引用的语义可以表示为或Φ区域,形式上是数组区域在概念上的一个拓广.利用区域、区域的覆盖关系,可以在既有数组数据流分析的框架下处理条件分支语句产生的流不确定性,增强传统的数组数据流分析.此外,Ω区域的覆盖技术还可以应用在符号分析等问题上.
　　本文第1节介绍在数据流分析的过程中如何表示、计算条件读写的Ω区域和Φ区域.第2节阐述利用Ω区域、Φ区域的覆盖关系得到更精确的数据流信息,并给出典型的实例.第3节同国外的相关工作进行比较.最后得出结论.
1 Ω区域、Φ区域的表示与计算
　　在最一般的意义下,条件谓词的Ω区域在Dom(P)空间中可能是非常复杂的空间区域,因而是难以计算的，判定其相互之间的覆盖关系在一般意义下是NP问题.令人却步的复杂度源于程序逻辑语义本身的潜在复杂性.
　　值得庆幸的是,编译器的分析优化并不需要处理所有可能的情况,而只需处理好实际情况中常见的、影响并行化变换的情形.对SPEC95fp,PERFECT等测试程序包的分析表明:条件谓词的Omega区域在其直接出现的变量集(t1,t2,...,tk)上通常可以表示为线性凸区域.把ΩT(t1,t2,...,tk)视为Omega区域的参数形式.当需要判定覆盖关系的Omega区域处在不同的参数空间时,进行参数的反向替代,以使它们处于同一参数空间,并进行覆盖关系的比较,如果参数替换过程产生过于复杂的表达式或过于复杂的Omega区域,使得判定Omega区域之间的覆盖关系变得过于复杂,可以视为静态不可判定的问题.对于程序段P,参数的替代最终只能进行到所有的参数全部替换为In(P)中的变量,所以这个替换过程可行,并且一定结束.
　　并行化编译器主要分析结构化的程序段,它们一般由表达式、赋值语句、条件分支语句、各种循环语句以及顺序结构构成.并行化变换主要优化确定次数的循环,例如FORTRAN中的DO循环,因为它们是最具有并行性的程序构造.DOWHILE和REPEAT-UNTIL类型的循环本质上是递归计算,难以有效地并行计算,因此这里不再考虑.
1.1 条件谓词的Omega区域表示
　　条件分支语句的逻辑谓词主要有这样几种常见的基本形式:数值关系的比较,如=,≤,≥,≠,＜,＞;整型变量的MOD运算;绝对值运算以及在此基础上的逻辑运算.由文献［3］中的引理1.1可知,逻辑谓词可以直接表示为Omega区域的特征函数表达式.
　　(1) 数值关系的比较,整型变量的MOD运算直接化为空间区域的约束方程、不等式.例如,
　　　　IF (X＞4)化为 Ω={Dom(P)|X＞4}，
　　　　IF (MOD(X,2)=0)化为 Ω={Dom(P)|mod(X,2)=0}.
　　(2) 绝对值运算化为线性方程组.例如,
　　　　IF (|X|＜1.0)化为 Ω={Dom(P)|X＜1.0;X＞-1.0}.
　　(3) 逻辑运算化为区域之间的交并补运算:
　　　　IF (C1 .and.C2)化为 Ω=Ω1∩Ω2,
　　　　IF (C1 .OR.C2)化为 Ω=Ω1∪Ω2,
　　　　IF (.NOT.C1)化为 Ω=(Ω1).
例如:
　　　　　IF (.NOT.(X＞4))化为　Ω=Ω1={Dom(P)|X≤4},
　　　　　IF ((X＞2).AND.(Y＞1)) 化为 Ω=Ω1∩Ω2={Dom(P)|X＞2;Y＞1},
以下简记{Dom(P)|p(x1,x2,...,xn)}为{p(x1,x2,...,xn)},“;”表示与关系.
1.2 嵌套在条件分支语句下的情形
　　设嵌套在条件分支语句if内部的Omega区域为Ωi,则在if之外其相应的Omega区域Ω0是Ωi与其所在if分支之条件谓词Omega区域的交.
　　由Φ区域的定义:ΦxP=Ωpx×SetP(x),Φ区域的计算只是相应Ω区域的计算.
　　例1:
　　Step 1.　IF (X＞4) THEN
　　Step 2.　　IF (Y＞0) THEN
　　Step 3.　　　DO I=1,10
　　Step 4.w 　　　　A(I)=...
　　Step 5.　　　ENDDO
　　Step 6.　　ENDIF
　　Step 7.　ENDIF
　　在程序段Step 3～Step 5中,w的数组引用区域是A(1:10);在程序段Step 2～Step 6中,Step 2的条件谓词的Omega区域是Ω2={Y＞0}.数组定义点w在程序段Step 2～Step 6范围中的Φ区域为
Φ2～6(w)=Ω2×Set2～6(w)={Y＞0}×{A(φ)|φ=1,...,10}.
在程序段Step 1～Step 7下,嵌套的Omega区域是Ω=Ω1∩Ω2={X＞4;Y＞0},数组定义点w的Φ区域为
Φ1～7(w)=Ω×Set1～7(w)={X＞4;Y＞0}×{A(φ)|φ=1,...,10}.
1.3 嵌套在DO语句中的情形
　　嵌套在DO语句中的IF语句,其计算语义可以非常复杂.这里只需考虑对数据流分析有利的几种常见情形.其他复杂情形可以用文献［3］中提出的忽略值不确定性IF语句的方法排除在分析范围之外.
　　嵌套在DO语句中的逻辑条件可以含有标量或数组变量.
　　如果嵌套在DO语句中的IF语句,其条件中仅含标量,而且是非递归标量,则该IF语句为循环不变条件分支语句,可以提到DO循环之外,用1.2节所述方式来处理.
　　如果含递归标量(induction variable),那么该逻辑条件是对循环的迭代空间进行约束的逻辑谓词.设条件引用x嵌套在程序段P的n重DO循环中,相应的循环变量为i1,i2,...,in,t1,t2,...,tk是直接出现在谓词P(t1,t2,...,tk)中的变量,该谓词确定的DT=Dt1×Dt2×...×Dtk中的区域ΩT,可以表示为i1,i2,...,in和In(P)上的方程和不等式组.当需要考虑X在n重循环之外的数据流关系时,需要把Omega区域投射到循环外程序段P的定义变量集In(P)上.投射过程把循环变量i1,i2,...,in从Omega区域表达式中消去,事实上,消去的过程与数组引用区域向DO循环外扩的过程对应.循环变量的语义作用从逻辑条件约束转变为数组区域的约束.
　　例2:
　　Step 1.　DO LL=1,31
　　Step 2.　　N=LL-2
　　Step 3.　　DO I=1,31
　　Step 4.　　　N=N+1
　　Step 5.　　　IF (N>=31) THEN
　　Step 6.w 　　　　Y(I,LL)=Y(I,LL)+S(I,LL)+TEM(I,LL)
　　Step 7.　　　ENDIF
　　Step 8.　　ENDDO
　　Step 9.　ENDDO
　　在循环体中(语句Step 4～Step 7),w的区域为
Φw4～7=Ωw4～7×Set4～7(w)={N≥31}×{Y(φ1,φ2)|φ1=LL;φ2=I}
={1≤LL,I≤31;LL+I-2≥31}×{Y(φ1,φ2)|φ1=LL;φ2=I}
={Y(φ1,φ2)|φ1=LL;φ2=I;1≤LL,I≤31;LL+I-2≥31},
出循环后,w在整个程序段P中的区域为
ΦwP=ΩwP×SetP(w)
=Dom(P)×{Y(φ1,φ2)|φ1+φ2-2≥31;1≤φ1,φ2≤31}
={Y(φ1,φ2)|1≤φ1,φ2≤31;φ1+φ2-2≥31},
在语句Step 1～Step 9中的条件区域是P的定义域
Ωw=Dom(P).
　　如果嵌套在DO循环中的IF语句,其逻辑条件含有数组变量,并且数组引用的下标表达式中含有递归标量(否则视为标量处理),此时的逻辑条件是关于该数组特定区域的向量式的逻辑条件,需要对逻辑条件进行向量化扩展.理论上,向量化的逻辑条件可以蕴含相当丰富和复杂的语义,但在并行化常见的科学计算类程序时,特别需要处理好以下两种常见的模式.
　　(1) 向量式逻辑条件的条件归约.此时数组的下标表达式一般是严格单调的,设循环的迭代空间大小为n,则根据各个被判定数组元素相对该逻辑条件是否成立可以有2n种情形,但在编译器里通常只需考虑全部成立或全部不成立的情形.条件全部成立时,归约变量进行一般的归约运算,相应的Ω区域为各个分量满足逻辑条件时的联立;条件全部不成立时,归约变量不变.相应的Ω区域为各个分量不满足逻辑条件时的联立.参见例3.
　　(2) 向量式逻辑条件对应下的向量引用.此时，逻辑条件和向量引用中的数组下标表达式一般都是严格单调的,根据逻辑条件中数组元素的取值决定是否对相应的引用数组元素进行读写引用.这里也只需考虑向量式逻辑条件全部成立或全部不成立的情形,并且相应的Ω区域计算方法同上,而被引用的数组区域同一般的数组区域计算方法相同.参见例4.
　　例3:
　　Step 1 KC=0
　　Step 2 DO K=1,9,1
　　Step 3 　　IF (RS(K).GT.CUT2) THEN
　　Step 4 　　　KC=KC+1
　　Step 5 　　ENDIF
　　Step 6 ENDDO
　　Step 3中的条件是RS(1:9)的向量化逻辑条件.KC定义在Step 1～Step 6的范围是值不确定性定义.如果KC是符号变量,则需要对其进行符号分析.KC对向量条件:RS(K).GT.CUT2,K=1,...,9进行了条件归约.因此KC的取值范围为0≤KC≤9.
　　KC=0对应条件Step 3全部不成立的Dom(P)中的一个区域

　　KC=9对应